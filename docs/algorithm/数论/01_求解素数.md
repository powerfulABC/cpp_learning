# 01 求解素数

> 素数(Prime number)的定义：素数，又叫质数。是所有大于1，且除了1和它本身外没有其他因数的正整数总称<br/>
> 自然数是大于1的所有正整数，它由素数和合数组成

## 1.1 判断一个数是否是素数

根据素数的定义，判断一个数`N`是否为素数，只需枚举`[2,N]`的所有整数，搜索是否其中有`N`的因子即可<br/>

但是搜索空间是否需要`[2,N]`这么大呢？如果不需要这么大的搜索空间，怎么压缩呢?<br/>

假设`N`存在两个因数`x`和`y`满足`x*y=N`且`x<=y` <br/>
则有

$$
    x*y=N \implies y = N / x  
$$

$$
    x <= y \implies x/y <= 1
$$

结合上面两个公式可以推出

$$
    x^2 <= N
$$

那么可以知道，如果`N`是一个合数，那么它的其中一个因子的最大值`x`满足

$$
    x<=\sqrt{N}
$$

而我们只需要搜索其中一个因子就可以了，这样搜索范围就被压缩到了[2, $\sqrt{N}$] <br/>

[判断一个数是否是素数cpp代码](../../../code/algorithm/数论/01_primer_number.cpp)
- 时间复杂度 O($\sqrt{N}$)
- 空间复杂度 O(1)

## 1.2 埃氏筛-快速找出`[1,N]`范围内的所有素数

如何快速找出`[1,N]`范围内的所有素数呢？最简单的方法是遍历这个区间，对区间内的每一个数都用 [1.1 判断一个数是否是素数](#11-判断一个数是否是素数)中的方法，这样很慢。<br/>

> 自然数由合数和质数组成，而合数是质数的倍数

因此去除所有质数的倍数，就等于去除了所有合数

以下是埃氏筛算法的步骤：

- 1、创建列表：从 2 开始，创建一个包含 2 到给定数值 n 的所有整数的列表。
- 2、选择下一个素数：从列表中选择下一个未标记的数，它是一个素数。
- 3、标记合数：标记这个素数的所有倍数（从这个数的平方开始，且不大于 n 的数）。
- 4、重复：重复步骤 2 和 3，直到列表的末尾。
- 5、输出素数：所有未标记的数都是素数。



埃氏筛（Eratosthenes' Sieve）是一种古老且高效的算法，用于找出小于某个给定数值的所有素数。这个算法的基本思想是反复标记出合数的倍数，直到剩下的所有未标记的数都是素数。以下是埃氏筛算法的步骤：

创建列表：从 2 开始，创建一个包含 2 到给定数值 n 的所有整数的列表。
选择下一个素数：从列表中选择下一个未标记的数，它是一个素数。
标记合数：标记这个素数的所有倍数（从这个数的平方开始，且不大于 n 的数）。
重复：重复步骤 2 和 3，直到列表的末尾。
输出素数：所有未标记的数都是素数。
例子：找出小于 30 的所有素数
以下是步骤的具体实现：

- 初始化列表：
2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29

- 从 2 开始，2 是一个素数，标记 2 的所有倍数：
2,3,,5,,7,,9,,11,,13,,15,,17,,19,,21,,23,,25,,27,,29

- 下一个未标记的数是 3，3 是一个素数，标记 3 的所有倍数：
2,3,,5,,7,,,,11,,13,,,,17,,19,,,,23,,25,,,,29

- 下一个未标记的数是 5，5 是一个素数，标记 5 的所有倍数：
2,3,,5,,7,,,,11,,13,,,,17,,19,,,,23,,,,,,29

- 下一个未标记的数是 7，7 是一个素数，标记 7 的所有倍数：
2,3,,5,,7,,,,11,,13,,,,17,,19,,,,23,,,,,,29

- 继续这个过程直到列表末尾。

- 最终，所有未标记的数就是小于 30 的素数：
2,3,5,7,11,13,17,19,23,29

[埃氏筛cpp代码](../../../code/algorithm/数论/01_primer_number.cpp)